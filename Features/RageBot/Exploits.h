#pragma once

class CUserCmd;
typedef void(__cdecl* CL_Move_t)(float, bool);

class CExploits {
public:
	enum ExploitType {
		E_None,
		E_DoubleTap,
		E_HideShots
	};

private:

	int defensive_ticks = 0;
	bool in_defensive = false;

	bool should_override_next_tickbase_shift = false;
	int override_next_tickbase_shift = 0;

	ExploitType exploit_type = E_None;
public:
	bool teleport_next_tick = false;
	bool shifting_tickbase = false;
	int target_tickbase_shift = 0;
	bool block_charge = false;
	int charged_command = 0;
	int charged_tickbase = 0;
	bool defensive_this_tick = false;
	bool allow_defensive = false;
	bool force_charge = false;
	int shot_cmd = 0;
	float last_teleport_time = 0.f;
	int def_skipped = 0;

	inline bool& IsShifting() { return shifting_tickbase; };
	inline float LastTeleportTime() { return last_teleport_time; };
	inline int& TargetTickbaseShift() { return target_tickbase_shift; };
	inline bool& DefenseiveThisTick() { return defensive_this_tick; };
	inline bool& AllowDefensive() { return allow_defensive; };
	inline ExploitType GetExploitType() { return exploit_type; };
	inline int GetDefensiveTicks() { return defensive_ticks; };
	inline void ForceCharge() { force_charge = true; };
	
	bool TeleportThisTick();
	bool IsHidingShot();
	bool	ShouldCharge();
	int		MaxTickbaseShift();
	void	HideShot();
	void	ForceTeleport();
	void	Run();
	void	HandleTeleport(CL_Move_t cl_move);
	void	DefensiveDoubletap();
	bool	ShouldBreakLC();
	bool	IsDefensiveActive();

	void	LC_OverrideTickbase(int shift);
	int		LC_TickbaseShift();
};

extern CExploits* Exploits;